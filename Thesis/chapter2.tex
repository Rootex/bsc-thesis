\chapter{Literature}
\section{Modular Development}
When it comes to software development, there are a bunch of approaches and for a fact, no single approach can be labeled as the best but can be the best in terms of a certain kind of system. When developing complex systems, whether in teams or as an individual, sometimes one tends to lose perspective when development becomes really bogus and in turn causes a project failure either due to the inability to produce the product that meets the customers requirements or due to complexity causing the management  of the software to be tedious. The idea of Modular Development is to overcome this problem of complexity by designing and developing a system that is manageable, simple and comprehensible simply by dividing the whole system into smaller units that can be managed individually. 

Modularity is a bit redundant as there are lots of different definitions of what a module really is, most of the definitions out there have no experimental proof. The word module is an overloaded term and can mean a number of things, in this thesis, the word module means an independent functional unit of an application that has no or less dependency on other modules except in point when it need another module to achieve it purpose. In this sense, a module will be represented either as a package or an application that can easily be removed or integrated into a bigger system.

Modular development or sometimes known as Modular approach to Software Development is a development technique that covers from the design to the implementation of software systems in terms of components or modules. This idea focuses on the separation of concerns, in which each functionality is developed as a module which is a logically discrete function and has no or less communication with other modules, except the point whereby it requires another module to achieve its purpose. 

Modular development consists of {\bf modular programming} which in turn has two aspects, being, design and implementation. These involves the software design technique and the implementation of the working code based on that design respectively. 

\subsection{Modular Programming}
{\bf Design}\\
{\bf Modular design} concentrates on the architectural design of a software system in terms of modules, in this design, the modules have to be clearly represented in such a way that each describes a logically discrete function and is comprehensible at first glance. The design tends to show the system modules as independent, scalable and reusable components and also the ease in extending the system with the matter of plugging new modules to it. 

It is important to design a modular architecture of a software system first before its implementation showing all dependencies, in this case, it will be difficult for the system to degenerate into an unmaintainable system without being noticed during development. There are a lot of tools that can be used to design a software systems architecture including UML tools, tools like Visual Paradigm for UML, UMLet, Rational Rhapsody e.t.c

\noindent {\bf Implementation}\\
This phase involves the {\bf implementation} of a software system by the aid of a modular architecture of the system and a programming language that supports or aids modularity. This method of programming disallows the use of control variables and flags which enables the caller to successfully call a module without knowing the details of how it was implemented. 

{\bf Modular programming} encourages the separation of concerns, dividing a system into independent modules such that each module performs a logically discrete function. There are different levels to which modularity can be achieved (depending on the size and type of the system); 1) Application level 2) Package level 3) Function/Method level. Programming languages that support modularity allows us to comfortably divide our system independently into the above stated levels. Specifically, in this thesis with the aid of our project, we will see how a system can be developed using the modular approach i.e dividing the system into package level modules and application level module receptively.

There are lots of languages that support modular programming, such languages are; C/C++, Java, Python, Perl, Pascal, Algo e.t.c.  And some of this programming languages provide us the feature of module encapsulation. Encapsulation is a method of hiding (in our case) module information from other modules, in other words, modules that do not have dependencies on others cannot access their information. This feature especially makes it possible to control module interdependencies and flexibility when managing and maintaining system modules, also allows us to avoid developing a monolithic bunch of tightly coupled code.

In modular programming, modules can communicate or be used by a system by {\bf Message} passing or the more conventional {\bf Call}. When a module is being called, control is handed over to that module and it will be so until the module is done with its operation there by handing control back to the caller. However, in some technologies now, it is possible to run multiple tasks at the same time by the use of "Threads".

\section{Benefits of applying Modular Development}
I have talked about modular development to a certain degree of detail, explaining how the structure is and different processes involved in this particular approach to software development. However there are a number of advantages of applying this technique to software development and some of those are: 
\begin{itemize}
\item{\bf Structured approach,} complex problems or systems can be broken down into smaller and simpler tasks that can be managed easily and maintained with less stress. This kind of approach sometimes referred to as the top-down design, which means, when there is a problem, it is split into smaller units and those units are in turn split into much smaller ones until the lowest functional level is reached.
\item{\bf Separation of concerns,} with this approach, we can easily separate different aspects of a system into modules in such a way that each (module) deals with a single logically discrete function with no interaction with other modules unless it needs another module to achieve its goal and one can easily look at a module and describe what it does in a single sentence. 
\item{\bf Distributed development,} modular development allows distributed development. By breaking down a complex system into smaller modules, each of this module can be assigned to be developed by a separate team or individuals, sometimes located in a different geographic region without any inconvenience. As one of the goals of this technique is to be able to utilize a module without having any idea on how it was developed, each modules can then be assembled or integrated into a system by someone other than their developers with less or no knowledge of how it was implemented.
\item{\bf Reuse,} by dividing a system into modules, a module can be reused throughout a system, this reduces code redundancy. Also not only can it (the module) be used in the same system it was developed for, but also can be utilized in projects in the future when a certain functionality it gives is needed.   
\end{itemize} 
